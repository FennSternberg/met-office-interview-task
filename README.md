# Minimum Temperature Estimation Toolkit

Python toolkit for estimating overnight minimum temperature (Tmin) using a Craddock & Pritchard style method, with small composable modules:
- predictors (`MinTempPredictor`, `CraddockAndPritchardModel`, `KTable`)
- parsers (`parse_initial_data`, `parse_k_table`)
- evaluation (`evaluate_predictor(s)` + MAE/RMSE/bias)
- plotting helpers (`plot_error_bars`, `plot_pred_vs_actual`)
- an optional calibration/optimisation prototype (`optimizers.py`)

## Repository layout
```
min_temp/                 Library code (predictors, parsers, metrics, plots, optimizers)
tests/                    Unit tests
data/                     Example datasets used by the notebook/tests
plots/                    Saved plots generated by the notebook
k_table.csv               Reference-book K-table (headerless CSV)
presentation.ipynb        Notebook-based talk / walkthrough (exportable to reveal.js slides)
presentation.slides.html  Pre-rendered slide export (generated from presentation.ipynb)
requirements.txt          Environment dependencies
README.md                 Project overview and usage notes
```

## Installation
- Developed with Python 3.13.
- Install deps: `pip install -r requirements.txt` (or at least pandas and matplotlib for toolkit, and notebook for the presentation).

## Base predictor contract (`MinTempPredictor`)
- Implement `.predict(row)` returning a float Tmin for a mapping/Series.
- Expose `name: str` and `feature_keys: tuple[FeatureKey, ...]` listing required inputs and their expected units.
- Any subclass can be passed to `metrics.py` (`evaluate_predictor` / `evaluate_predictors`) for accuracy analysis.

Minimal example predictor:
```python
from min_temp import FeatureKey, MinTempPredictor

class ConstantMinusDewpoint(MinTempPredictor):
    name = "const_minus_dew"
    feature_keys = (FeatureKey("midday_dew_point_c", "deg C"),)

    def predict(self, row):
        return float(row["midday_dew_point_c"]) - 2.0
```

Using metrics and plots with the simple predictor:
```python
import pandas as pd
from min_temp import evaluate_predictors, plot_error_bars, plot_pred_vs_actual

rows = pd.DataFrame({
    "midday_dew_point_c": [10, 8, 6],
    "observed_min_temp_c": [7.5, 6.0, 4.5],
})
model = ConstantMinusDewpoint()
results = evaluate_predictors(rows, {"ConstMinusDew": model}, actual_key="observed_min_temp_c")

plot_error_bars(results, save_path="plots/errors.png")
plot_pred_vs_actual(results, save_path="plots/pred_vs_actual.png")
```
Both plotting functions accept an iterable of `PredictionResult`.

## Craddock & Pritchard predictor
`CraddockAndPritchardModel` implements the reference-book formula:
```
Tmin = a * T12 + b * Td12 + c + K(wind_bin, cloud_bin)
```
Expected input columns:
- `midday_temp_c` (T12)
- `midday_dew_point_c` (Td12)
- `wind_kn`
- `cloud_oktas`

K-table:
- Wind and cloud edges are upper bounds
- Binning is right-closed (first edge `>=` value).
- `KTable.lookup(...)` raises if the selected cell is undefined (`NaN` / “Unknown”) or out of bounds.
- A default K-table is embedded in `CraddockAndPritchardModel`
- `k_table.csv` is provided as a convenient external representation, loaded with parse_k_table.
- Parse CSV tables with `parse_k_table(path)` to get a `KTable` (headerless format, like `k_table.csv`).

Quick start with bundled data:
```python
from min_temp import CraddockAndPritchardModel, parse_initial_data, parse_k_table

observations = parse_initial_data("data/initial_data.csv")
k_table = parse_k_table("k_table.csv")

model = CraddockAndPritchardModel(k_table=k_table)
observations["predicted_min_temp_c"] = observations.apply(model.predict, axis=1)
print(observations[["Date", "Location", "predicted_min_temp_c"]])
# Example outputs for the bundled sample:
# 11.8116, 10.9698, 9.4340, 7.4824
```

Customising input headers (if your CSV uses different column names):
```python
observations = parse_initial_data(
    "my_data.csv",
    midday_temp_header="T12 (C)",
    midday_dew_point_header="Td12 (C)",
    wind_speed_header="Wind (knots)",
    cloud_cover_header="Cloud (oktas)",
)
```

Custom parameters:
```python
custom_k = parse_k_table("k_table.csv")
model = CraddockAndPritchardModel(a=0.25, b=0.6, c=-0.8, k_table=custom_k)
```

Evaluating accuracy (metrics/plots work the same as the simple predictor):
```python
from min_temp import evaluate_predictor

observations["observed_min_temp_c"] = [12.3, 11.0, 8.9, 8.5]
metrics = evaluate_predictor(observations, model, actual_key="observed_min_temp_c")
print(metrics.mae, metrics.rmse, metrics.bias)
```

## Optimizer (`optimizers.py`)
`OptimizerFactory` is a small least-squares framework for models that are linear in their parameters.

`CraddockAndPritchardOptimizer` builds on it to fit `a`, `b`, `c`, and K-table cells.

Key entry points:
- `fit(df, target_col="observed_min_temp_c", fixed=None)` -> `FittedModel` (fitted model, metrics, param dict).
- `prepare_fit(df, ...)` -> `FitWorkspace` (residual + design columns) for plugging in an external solver.
- `solve(workspace)` -> `dict[str, float]` of solved parameters.

Important:
- Every fitted parameter must have support in the data (e.g., wind/cloud bins must be hit), otherwise you must fix it.

Worked example (synthetic 2x2 K-table, identifiable):
```python
import pandas as pd
from min_temp import CraddockAndPritchardModel, CraddockAndPritchardOptimizer, KTable

true_a, true_b, true_c = 0.3, 0.5, -1.0
k_values = pd.DataFrame(
    data={
        2.0: [1.0, 3.0],
        5.0: [2.0, 4.0],
    },
    index=[10.0, 20.0],
)
true_k_table = KTable(k_values)
true_model = CraddockAndPritchardModel(a=true_a, b=true_b, c=true_c, k_table=true_k_table)

rows = [
    {"midday_temp_c": 10, "midday_dew_point_c": 4,   "wind_kn": 8,  "cloud_oktas": 1},
    {"midday_temp_c": 12, "midday_dew_point_c": 7,   "wind_kn": 9,  "cloud_oktas": 4},
    {"midday_temp_c": 8,  "midday_dew_point_c": 3.5, "wind_kn": 15, "cloud_oktas": 1},
    {"midday_temp_c": 6,  "midday_dew_point_c": 2.0, "wind_kn": 18, "cloud_oktas": 4},
    {"midday_temp_c": 11, "midday_dew_point_c": 5,   "wind_kn": 8,  "cloud_oktas": 1},
    {"midday_temp_c": 13, "midday_dew_point_c": 6,   "wind_kn": 9,  "cloud_oktas": 4},
    {"midday_temp_c": 9,  "midday_dew_point_c": 5,   "wind_kn": 15, "cloud_oktas": 1},
    {"midday_temp_c": 7,  "midday_dew_point_c": 2.5, "wind_kn": 18, "cloud_oktas": 4},
]
df = pd.DataFrame(rows)
df["observed_min_temp_c"] = df.apply(true_model.predict, axis=1)

fitted = CraddockAndPritchardOptimizer(a=0.0, b=0.0, c=0.0, k_table=true_k_table).fit(df)
print("Recovered params:", fitted.params)
print("MAE:", fitted.metrics.mae)
```

Fix parameters during fitting:
```python
fixed = {"a": true_a, "k:10.0:2.0": 1.0}  # lock coefficient a and one K cell
fitted = CraddockAndPritchardOptimizer(a=0.0, b=0.0, c=0.0, k_table=true_k_table).fit(df, fixed=fixed)
```
`fit` returns `PredictionResult` metrics so you can compare fitted vs. baseline models with `plot_error_bars` / `plot_pred_vs_actual`.

## Included data
- `k_table.csv`: K lookup (wind edges as rows/index, cloud edges as columns/headers).
- `data/initial_data.csv`: sample midday observations (no Tmin column).


## Quick reference
- Predictors: `MinTempPredictor` (base), `CraddockAndPritchardModel`.
- Calibration: `OptimizerFactory`, `CraddockAndPritchardOptimizer`, `FittedModel`, `FitWorkspace`.
- Parsing: `parse_initial_data`, `parse_k_table`, `KTable`.
- Metrics/plots: `compute_metrics`, `evaluate_predictor`, `evaluate_predictors`, `plot_error_bars`, `plot_pred_vs_actual`.

## Tests
Run from repo root:
```bash
python -m unittest discover -s tests
```
